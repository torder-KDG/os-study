### **배경**
<hr>

- 메모리는 각각의 주소가 할당된 일련의 바이트 코드로 구성되어 있습니다. 즉 바이트 코드의 나열입니다.
- CPU는 program counter(PC)가 지시하는 대로 메모리로부터 다음에 수행해야하는 명령어를 가져오는데, 해당 명령어는 필요한 경우 추가적인 데이터를 가져오거나
 반대로 데이터를 메모리로 내보낼 수 있습니다.


#### **기본 하드웨어**

- 메인 메모리와 각 코어 레지스터는 CPU가 직접 접근할 수 있는 유일한 범용 저장장치입니다. 기계 명령어들은 메모리 주소만을 취급하고, 디스크의 주소는 취급하지 않기
때문에 실행되는 모든 명령어와 데이터들은 CPU가 직접 접근할 수 있는 메모리나 레지스터에 있어야합니다. 만약 데이터나 메모리나 레지스터에 없다면 CPU가 
그것을 처리하기 전에 적재해야 합니다.
- 각각의 프로세스는 독립된 메모리 공간을 가질 수 있도록 보장해야하는데 이러한 독립적인 메모리 공간은 프로세스별로 보호하고, 병행 실행을 위해 여러 프로세스가
메모리에 적재되는것이 필수입니다.
- 프로세스마다 개별적인 메모리 공간을 가지기 위해서는 특정 프로세스만 접근할 수 있는 합법적인 메모리 주소 공간을 설정하고, 해당 프로세스만 접근하도록 해야합니다.
- 메모리 공간의 보호는 CPU 하드웨어가 사용자 모드에서 만들어진 모든 주소를 비교함으로써 이루어지는데, 사용자 모드에서 수행되는 프로그램이 운영체제의 메모리 공간이나 다른 
사용자 프로그램의 메모리 공간에 접근하면 운영체제는 오류로 간주하고 트랩을 발생시킵니다.

##### **기준 레지스터**

- 가장 작은 합법적인 물리 메모리 주소의 값을 저장하고 있습니다.

##### **상한 레지스터**

- 주어진 영역의 크기를 저장하고 있습니다.

![스크린샷 2023-04-12 오후 8 59 29](https://user-images.githubusercontent.com/107396231/231450393-be903cd0-d5d5-495b-be29-8a5466e4ba3a.png)

#### **주소의 할당**

- 프로그램은 이진 실행파일로 디스크에 저장되어 있는데, 이 프로그램을 실행시키기 위해서는 메모리에 적재해야 합니다.
- 주소를 할당하기 위해서는 링커와 로더에 대해 살펴볼 필요가 있습니다.

##### **링커(Linker)**

- 링커는 여러가지를 연결하는것이다 라고 생각하면 이해하기 쉬울거 같습니다.
- 예를들어 프로그래머가 작성한 소스 코드를 컴퓨터가 이해할 수 있는 언어로 변환하는 작업을 컴파일링이라고 합니다. 그리고 컴파일된 것을 실행가능한 파일로 변환하는것을 링킹이라 합니다.
- 링커는 프로그램에서 사용된 모든 함수나 변수가 해당 정의에 맞는지 확인되도록 서로 다른 개체 파일과 라이브러리 간의 참조를 확인합니다.

##### **로더**

- 로더는 이진 실행파일을 메모리에 적재하는데 사용됩니다. 링커가 어떠한 프로그램을 실행시키기 위해 연결을 했다면 연결된 것을 실행하기 위해 메모리에 적재하는 역할을 수행하는게 로더라 할 수 있습니다.

#### **주소를 할당하는 3가지 방법**

##### **Compile Time Binding**

- 프로세스의 물리적 주소가 컴파일 시점에 정해집니다.
- 프로세스가 자신이 어느 위치에 들어가야할지 미리 알고 있다면 컴파일러는 절대 주소를 생성할 수 있습니다.
- 만약 실행도중 위치가 변경되어야 한다면 재컴파일 해야합니다.

##### **Load Time Binding**

- 프로세스가 자신이 메모리의 어느 위치에 들어가야할지 컴파일시점에 알지 못한다면 재배치 가능 코드를 생성해야 합니다. 이러한 재배치 가능 코드는
메모리의 어느 위치에서나 수행될 수 있는 기계어 코드인데 로더가 프로세스를 메모리에 적재하는 시점에 물리 주소를 결정하게 됩니다. 
그렇기 때문에 논리 주소와 물리 주소는 다르게 됩니다.

##### **Execution Time Binding**

- 프로세스가 수행이 시작된 이후에 프로세스가 실행될 때 메모리 주소를 변경하는 방법입니다.
- 실행시점에 물리 주소가 결정되며, 실행도중에도 물리 주소가 변경될 수 있습니다.
- 실행시간 주소 할당은 CPU가 주소를 참조할 때마다 address mapping table을 이용하여 바인딩을 점검합니다. 이러한 방식은 MMU라는 하드웨어 장치를 사용하여 논리적 주소를 물리적 주소로 변환하게 됩니다.

##### **Execution Time Binding는 어떻게 주소를 매핑시킬까?**

- 실행시간 주소 할당은 프로그램 실행중에 논리 주소를 물리 주소로 변환시켜줘야 하는데 이 작업은 하드웨어 장치인 MMU에 의해 실행됩니다.
- MMU를 사용한 기법에서는 기준 레지스터를 재배치 레지스터라 부르고, 이 재배치 레지스터를 사용하여 논리 주소가 물리 주소로 보내질 때 해당 논리 주소에 
임의의 값이 더해지게 됩니다. 그렇기 때문에 사용자 프로그렘은 결코 실제적인 물리주소에 접근할 수 없게 됩니다.
- 사용자 프로그램은 논리 주소를 사용한 것이고, 메모리 하드웨어는 논리 주소를 물리 주소로 바꾼것입니다.

![스크린샷 2023-04-12 오후 9 13 23](https://user-images.githubusercontent.com/107396231/231453574-363290f9-4241-445c-84cd-2d8ed3cf79c3.png)

<br>

### **연속 메모리 할당**
<hr>

- 메모리는 일반적으로 두 개의 부분으로 나누어지는데, 하나는 운영체제를 위한것이고 다른 하나는 사용자 프로세스를 위한 것입니다.
- 연속 메모리 할당은 이름에서 알 수 있듯이 각 프로세스들이 연속적인 메모리 공간을 차지하는 것입니다.

#### **메모리 보호**

- 연속 메모리 할당은 각 프로세스들이 연속적으로 메모리 공간을 차지하고 있기 때문에 각 프로세스별 메모리를 어떻게 보호할 수 있는가에대해 문제가 발생할 수 있습니다.
이러한 문제를 해결하기 위해서는 상한 레지스터와 재배치 레지스터를 사용하여 문제를 해결할 수 있습니다.
- CPU 스케줄러가 다음으로 수행할 프로세스를 선택할 때 디스패처는 context-switch할 때 재배치 레지스터와 상한 레지스터에 정확한 값을 적재합니다.
CPU에 의해 생성되는 모든 논리 주소는 이 레지스터들의 값을 참조해서 확인 작업을 거치기 때문에 운영체제와 다른 사용자 프로그램을 현재 수행중인 프로그램의 접근으로부터 보호할수 있습니다.

![스크린샷 2023-04-12 오후 9 19 47](https://user-images.githubusercontent.com/107396231/231455040-6b88f31b-5a37-4904-ac1f-67ee54729b8d.png)

#### **메모리 할당**

- 연속적인 메모리를 할당하기 위해서는 고정된 크기로 나누는 고정 분할과 프로세스의 크기를 고려해 나누는 가변 분할 방식이 있습니다.

##### **고정 분할**

- 분할의 크기가 모두 동일하거나, 서로 다를 수 있습니다. 분할 당 하나의 프로세스가 적재되기 때문에 동시에 메모리에 적재되는 프로세스의 수가 고정됩니다. 또한 수행가능한 프로세스의 최대 크기가 제한됩니다.

##### **가변 분할**

- 프로세스를 메모리의 가변 크기 파티션에 할당하는 것입니다.
- 각 파티션에는 하나의 프로세스만 할당할 수 있습니다.
- 가변 파티션 기법에는 운영체제가 사용 가능한 메모리 부분과 사용중인 메모리 부분을 나타내는 테이블을 사용하게 됩니다. 처음에는 모든 메모리가 사용자 프로세스에 사용 가능하며, 하나의 큰 사용 가능한 메모리 블록인 hole로 간주합니다.

##### **동적 메모리 할당 문제를 해결할 수 있는 기법**

- 최조 적합: 첫번째 사용 가능한 공간을 할당합니다.
- 최적 적합: 사용 가능한 공간 중 가장 작은 것을 할당합니다.
- 최악 적합: 가장 큰 사용 가능한 공간을 할당합니다.

#### **단편화**

- 단편화에는 외부 단편화와 내부 단편화가 있습니다.


